字符串
1.字符串的概念
**字符串是一个长度有限的字符序列。
**字符串有以下常见概念：
（1）字符串名
（2）字符串值
（3）字符串相等
（4）空格串
（5）字符串相等
（6）子串
（7）子串的位置
**字符串的常用运算：
（1）判断两个字符串是否相等
（2）求字符串的长度
（3）连接两个字符串
（4）求子串
（5）子串替换
（6）子串定位
2.字符串的存储结构
**作为一种特殊的线性表，字符串可以采用顺序存储结构和链式存储结构
2.1 顺序存储结构
**顺序存储结构可以采用：
（1）静态存储。char str[n];
（2）动态存储。char *str=(char*)malloc(sizeof(char)*n);
2.2 链式存储结构
**字符串采用链式存储结构时，每个节点包含一个字符域和一个指针域
指针域存放指向下一个结点的指针。在字符串的链式存储结构中，一个节点存储
的字符数量称为该结点的大小。

**尽管字符串既可以采用顺序结构，也可以采用链式结构存储，但由于字符串的操作中
以子串为单位的操作较多，而已链式存储结构为基础实现子串的多种操作并不方便。故
本节以静态分配的顺序存储结构为例说明字符串的运算
3.字符串的关键运算
3.1 子串定位
**子串定位：给定两个字符串，即字符串D和字符串M，求字符串M在字符串D中的位置
其中字符串D称为目标串，字符串M称为模式串，因此子串定位又称为字符串的模式匹配
**子串定位有两种方法：
（1）穷举法。又称为蛮力算法
（2）KMP算法
**********************KMP算法**********************
1.相关概念
**已匹配子串：把模式串中第一个不匹配字符之前的子串称为已匹配子串
**已匹配子串的前缀：已匹配子串中所有包含其第一个字符的子串（不包含已匹配子串本身）
称为已匹配子串的前缀
**已匹配子串的后缀：已匹配子串中所有包含其最后一个字符的子串（不包含已匹配字串本身）
称为已匹配子串的后缀
**部分匹配串：已匹配子串的前缀和后缀中最长且相等的一个子串称为已匹配子串的部分匹配串
2.基本思路
**在模式串与目标串进行比较时，出现了第一个不匹配的字符
**与穷举法相反，当匹配出现时，KMP算法将模式串向后移动尽可能多的字符数，然后开始新一轮比较
**KMP算法向后移动的字符数为
	移动字符数=已匹配子串长度-对应部分匹配串的长度
**移动后从上一次发生不匹配的位置开始向后进行比较，重新开始比较时，模式串前面的子串是部分匹配，
已经匹配成功，此时不需要再比较了。
**KMP算法的精髓在于求取部分匹配的字符串的长度
**在KMP算法中所有已匹配子串都是模式串str的前缀，所以我们只需要求解模式串str所有前缀的部分匹配串，
并将其存入next数组中，其中，next[i]表示{str[0],str[1],str[2],...str[i]}所构成的子串(前缀)的
部分匹配串的长度。
**********************以下为代码**********************
void partStringLen(char str[],int n[],int len){
	int i=1,j=0;
	n[0]=0;
	while(i<len){
		if(str[i]==str[j]){
			n[i]=j+1;
			i++;
			j++;
		}else if(j>0){
			j=n[j-1];
		}else{
			n[i++]=0;
		}
	}
}
*******************************************************
在理解此代码之前应先搞清楚各变量的精准的意思，以下为各变量的含义：
len表示模式串的长度
i表示模式串的前缀的终点位置(下标index)，同时也是相对应的next数组的下标
**此处相对应的意思是如上，即：next[i]表示{str[0],str[1],str[2],...str[i]}
所构成的子串(前缀)的部分匹配串的长度。
j表示正在匹配的字符的下标
**下面结合代码进行说明
最关键的为if-else语句
1.假设next[i-1]已求出，此时，i移动到i位置，j移动j位置。则意味着
{str[0],str[1],...,str[j-1],...,str[i-j],...,str[i-2],str[i-1]}此前缀中
的部分匹配串为{str[0],str[1],...,str[j-1]}={str[i-j],...,str[i-2],str[i-1]}
字符匹配串的长度显然为j,此时需要注意next[i-1]与j的关系
2.如果此时str[i]==str[j],则显然部分匹配串得到扩充，next[i]=next[i-1]+1=j+1;
3.如果此时str[i]!=str[j],此时令j=next[j-1],为什么要令j=next[j-1]呢?这是理解KMP的关键
为避免造成混淆，我们先令k=next[j-1],那么k是什么呢？结合1中的假设，我们知道k=next[j-1]的意思为
{str[0],str[1],...,str[k-1],...,str[j-k],...,str[j-2],str[j-1]}的部分匹配串为
{str[0],str[1],...,str[k-1]}={str[j-k],...,str[j-2],str[j-1]}，根据
{str[0],str[1],...,str[j-1]}={str[i-j],...,str[i-2],str[i-1]}，我们不难得出
{str[0],str[1],...,str[k-1]}={str[i-k]...,str[i-2],str[i-1]}，
原理即如此，为了得到递归，我们令j=k=next[j-1],此时如果即回到了第2步.