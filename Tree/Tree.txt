树和二叉树
***************************树**************************
1.树的定义
**树是有n(n>=0)个结点的有限集合(n等于0时称为空树)
在一棵非空树中：
（1）有且仅有一个特定的结点称为根结点
（2）当n>1时，除根结点之外的结点又分为m个互不相交的子集，
	每个子集又是一颗树，称为根结点的子树。
2.树的常用术语
（1）结点的度：每个结点的孩子结点的数目称为该结点的度。
（2）叶子结点：度为0的结点称为叶子结点
（3）分支结点：度大于0的结点称为分支结点
（4）树的度：树中所有结点中度的最大值称为树的度
（5）结点的层次：根结点的层次为第一层，根结点的孩子结点为第二层，
其余结点的层次依此类推。
（6）树的深度：树中结点的最大层次称为树的深度。
（7）有序树、无序树：如果将树中结点的孩子结点看做从左到右有序的，
则称该树为有序树，否则为无序树。
（8）森林：m(m>=0)棵互不相交的树的集合称为森林。树中任一结点的
子树的集合即是森林，称为该结点的子树森林。
***************************二叉树**************************
1.二叉树的定义
**二叉树是有n(n>=0)个结点的有限集合(n等于0时称为空二叉树)，在一棵
非空二叉树中：
（1）有且仅有一个特定的结点称为根结点
（2）当n大于1时，除根结点外的结点又分为互不相交的子集L和R,
L和R也都是二叉树，L称为二叉树的左子树，R称为二叉树的右子树。
L的根结点称为二叉树的左孩子，R的根结点称为二叉树的右孩子。
**二叉树与度为2的树比较类似，但是二叉树与度为2的树是不同的。
它们的不同之处在于：度为2的树的两个子树没有顺序，无左右之分；
而二叉树的两个子树是有顺序的，分为左子树和右子树。
2.两种特殊形态的二叉树
（1）满二叉树：满二叉树是一棵深度为k，且有2^k-1个结点的二叉树。满二叉树
中，所有的分支结点都有左孩子和右孩子。如果对满二叉树的结点从根结点开始，
按从上而下、自左至右的顺序编号，根结点的编号为1，则最后一个结点的编号为
2^k-1。
（2）完全二叉树：给定一个深度为k的二叉树，从它的根结点开始，按从上而下、
自左至右的顺序编号，根结点的编号为1，最后一个结点的编号为n，当且仅当它的
每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应时，该二叉树称为
完全二叉树。
3.二叉树的存储结构
（1）顺序存储结构
（2）链式存储结构
4.二叉树的遍历算法
（1）无结构方式
	仅将二叉树看成一个图，不考虑其结构特点。这时可以采用图的遍历算法，
即深度优先遍历算法和广度优先遍历算法。
（2）层次方式
	由于二叉树具有明显的层次结构，可以把二叉树看做若干个结点层的集合，
遍历的时候逐层遍历各层的特点，就形成了对二叉树的层次遍历。
	层次遍历的基本思路是建立一个存放二叉树结点的队列，从根结点开始遍历，
当遍历一个结点的时候就把它的左孩子和右孩子加入队尾；队头元素作为下一个
要遍历的结点;当队列为空时结束遍历
（3）递归方式
	根据二叉树的定义，可以将二叉树分为3个组成部分，即根结点、根结点的左子树、
根结点的右子树，然后对这3部分分别进行遍历。根结点的左子树和根结点的有子树又
都是二叉树，故又可以按照同样的方法对它们进行遍历，这样就形成了对二叉树的递归
遍历。
	若以T、L、R分别代表遍历根结点及其左右子树，则其对二叉树的遍历可以有以下6种
方案：TLR、LTR、LRT、TRL、RTL、RLT。前面3种和后面3种方案遍历根结点左右子树的顺序相反。
如果要求以先左子树后右子树的顺序进行遍历，则有三种遍历方案：TLR、LTR、LRT。这三种方案
分别称为先序遍历、中序遍历和后序遍历。
	先序遍历的基本思路：先遍历根结点，其次先序遍历根结点的左子树，最后先序遍历根结点的
右子树。
	中序遍历的基本思路：先中序遍历根结点的左子树，其次遍历根结点，最后中序遍历根结点的
右子树。
	后序遍历的基本思路：先后序遍历根结点的左子树，其次后序遍历根结点的右子树，最后遍历
根结点。
**递归遍历算法的时间复杂度与空间复杂度
	a.时间复杂度
		由于递归方式的遍历算法，每个结点都要访问一次，因此，时间复杂度为O(n)
	b.空间复杂度
		三种递归遍历算法执行时都需要一个递归栈，栈的最大深度与二叉树的深度一致。故而
	最坏情况下，它们的空间复杂度为O(n)
**************************************************************************************
以下为BTree测试用例
1 2 4 -1 -1 5 6 -1 -1 7 -1 -1 3 -1 -1
**************************************************************************************
5.线索二叉树
	根据二叉树的二叉链表数据结构，一颗具有n个结点的二叉树，其二叉链表中有n+1个空指针域。
在以某种方法遍历二叉树时，将一个结点的前驱结点和后继结点的指针保存在该结点的空闲指针域中。
以后根据保存在空闲指针域中的指针就可以遍历二叉树，从而避免了递归遍历过程，大大提高了程序
效率。保存在空闲指针域中的指针信息成为遍历二叉树的线索，根据该线索能够完成对二叉树的遍历。
	保存了线索的二叉树称为线索二叉树，对二叉树加线索的过程称为二叉树线索化。
	线索二叉树的构造方法，定义两个标志LTag和RTag,它们的作用如下：
	（1）当LTag==0时，说明有左孩子，LChild存放左孩子的指针
		 当LTag==1时，说明没有左孩子，LChild存放遍历寻列的前驱
	（2）当RTag==0时，说明有右孩子，RChild存放右孩子的指针
		 当RTag==1时，说明没有右孩子，RChild存放遍历寻列的后继
**************************************************************************************
6.二叉排序树
	二叉排序树是一种特殊的二叉树，其左子树均小于根结点，右子树均大于根结点，并且具有以下
特性：
	（1）若左子树非空，则左子树上所有结点的关键字均小于根结点的关键字
	（2）若右子树非空，则右子树上所有结点的关键字均大于根结点的关键字
	（3）左、右子树均为二叉排序树
	二叉排序树有一个重要的特性，即对二叉排序树做中序遍历时会得到一个有序序列。
**二叉排序树的删除
	二叉排序树的删除运算是指删除二叉树中一个值为定值的结点，其基本要求是不改变
二叉排序树的性能，即删除结点之后的树仍为二叉排序树。二叉排序树的删除主要由三
种情况：
	（1）待删除的结点只有左孩子
	（2）待删除的结点只有右孩子
	（3）待删除的结点既有右孩子也有左孩子
***************************************************************************************
7.最优二叉树
	最优二叉树又称哈夫曼树，在编码和决策方面有着广泛的应用。
**最优二叉树的相关概念
	路径：树中的两个结点之间所经过的分支，称为他们之间的路径
	路径长度：一条路径上的分支树，称为该路径的长度
	结点的权：给二叉树中的一个结点赋一个数，该数称为该节点的权
	结点带权路径长度：从根结点到一个结点的路径长度与该结点的权值的乘积，称为该结点的
	带权路径长度。
	树的带权路径长度：一棵树中所有叶子结点的带权路径长度之和，称为该树的带权路径长度WPL,
	WPL的公式如下：
		WPL=sum(W(i)*P(i)),i=1,2,3,4,......,n
	其中，n为树中叶子结点的个数，W(i)和P(i)分别为第i个结点的权值和从根结点到该路径的长度。
	最优二叉树：在具有n个带权叶子结点的所有二叉树中，称带权路径长度WPL最小地二叉树为最优二叉树。
**最优二叉树的构造
	基本思想：在构造二叉树时，如果使权值大的叶子结点离根结点很近，权值小的叶子结点离根结点很远，则
能够减小二叉树的带权路径长度。哈夫曼最早根据这个思路提出了构造最优二叉树的算法，称为哈夫曼算法。
	基本思路：
	（1）用给定的n个权值（w1,w2,w3,......,wn）构造n棵二叉树，每棵二叉树Fi只有一个根结点，其权值为
	wi,将n棵二叉树放在集合S中
	（2）当S中的二叉树数量大于1时，从中选择根结点权值最小的两棵树，并以他们为左右子树构造一棵新的二叉树，新的二叉树根结点的权值为其左右子树根结点的权值之和。
	（3）从S中删除选择的这两棵二叉树，并将新的二叉树放到结合S中，继续步骤（2）
***************************************************************************************
8.树的存储结构与运算
8.1 孩子表示法
	树中的每个结点存放数据元素和指向其孩子的指针。因为树中的每个结点可能有多个孩子，故
每个结点需要多个指针域，每个指针指向一个孩子。
	（1）定长结点结构
	每个孩子指针域的数量相同，其值等于树的度，使得所有结点结构完全一致，其结构如下:
	**********************************************************
	*data*child-1*child-2*child-3*child-4*child-5*...*child-n*
	**********************************************************
	其中n为树的度
	（2）不定长结点结构
	********************************************************
	*data*num*child-1*child-2*child-3*child-4*...*child-num*
	********************************************************
8.2 孩子兄弟表示法
	使用孩子兄弟表示法时，树中的每一个结点又一个数据域和两个指针域。其中，数据域存储数据，
左指针域存储指向其第一个孩子结点的指针，右指针域指向其下一个兄弟结点的指针。这种表示法要求
结点的孩子之间有明确的顺序关系，比较适用于有序树。
/**************************孩子兄弟表示法结点类型定义**************************/
#define MaxNode 200
typedef char DataType;
typedef struct tnode{
	DataType data;
	struct tnode *firstchild;
	struct tnode *nextchild;
}CSTreeNode;
/**************************孩子兄弟表示法结点类型定义**************************/
8.3 双亲表示法
	双亲表示法可以用一组连续的存储单元存储树中的所有结点。每个结点包含两个域：数据
域和指针域。数据域存储结点数据，指针域存储双亲结点在连续存储单元中的下标。
/**************************双亲表示法结点类型定义******************************/
#define MaxNode 200
typedef char DataType;
typedef struct{
	DataType data;
	int parent;
}TNode;
typedef struct{
	TNode nodes[MaxNode];
	int n;
}PTree;
/**************************双亲表示法结点类型定义******************************/
以下为树的测试用例:A(B(E,F,G),C(H,I),D)



